---
title: "introduction"
---

# Interaction with deBridge Infrastructure

Interaction with the deBridge infrastructure is as simple as calling the `send` method of the `debridgeGate` smart contract deployed on all supported
blockchains. The method can be called by any arbitrary address â€” either EOA or smart contracts.

```solidity
function send(
    address _tokenAddress,
    uint256 _amount,
    uint256 _chainIdTo,
    bytes memory _receiver,
    bytes memory _permit,
    bool _useAssetFee,
    uint32 _referralCode,
    bytes calldata _autoParams
) external payable;
```

## Method Parameters

| Parameter Name   | Type     | Description                                                                                         |
|------------------|----------|-----------------------------------------------------------------------------------------------------|
| `_tokenAddress`  | address  | Address of the token being sent (`address(0)` for chain base assets like ETH)                      |
| `_amount`        | uint256  | Token amount to be transferred                                                                      |
| `_chainIdTo`     | uint256  | Id of the receiving chain                                                                            |
| `_receiver`      | bytes    | Address of the receiver                                                                             |
| `_permit`        | bytes    | [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612) permit signature (if token supports it)         |
| `_useAssetFee`   | bool     | Should be set to `false`. Reserved for future governance usage                                     |
| `_referralCode`  | uint32   | Your generated referral code                                                                        |
| `_autoParams`    | bytes    | Structure that enables passing arbitrary messages and call data                                     |

<Tip>

If you integrate with or build applications on top of the deBridge infrastructure, make sure you specify your referral code that can be generated by
pressing the INVITE FRIENDS button at https://app.debridge.finance/. Governance may thank you later for being an early builder.

</Tip>
---

## AutoParams Structure

`_autoParams` allows passing arbitrary messages and call data to be executed as an external call to the receiver address on the destination chain. It
also enables setting an `executionFee`, which rewards the wallet/keeper that completes the transaction.  It enables a crypto-economic design where gas
fees are paid from the blockchain where the transaction is initiated. The `_autoParams` field has the following structure:

```solidity
struct SubmissionAutoParamsTo {
    uint256 executionFee;
    uint256 flags;
    bytes fallbackAddress;
    bytes data;
}
```

| Parameter Name     | Type     | Description                                                                                            |
|--------------------|----------|--------------------------------------------------------------------------------------------------------|
| `executionFee`     | uint256  | Suggested reward (in tokens) paid to executor on the destination chain                                 |
| `flags`            | uint256  | Bitmask flags that define execution logic                                                              |
| `fallbackAddress`  | bytes    | Address to receive tokens if external call fails                                                       |
| `data`             | bytes    | Message/call data to be passed to the receiver on destination chain during the external call execution |

---

## Flags

Flags are a bitmask that customize transaction execution flow on the destination chain. You can combine multiple flags by setting respective bits to
`1` simultaneously.

```solidity
library Flags {
    uint256 public constant UNWRAP_ETH = 0;
    uint256 public constant REVERT_IF_EXTERNAL_FAIL = 1;
    uint256 public constant PROXY_WITH_SENDER = 2;
    uint256 public constant SEND_HASHED_DATA = 3;
    uint256 public constant SEND_EXTERNAL_CALL_GAS_LIMIT = 4;
    uint256 public constant MULTI_SEND = 5;
}
```

| Flag Name                    | Value | Description                                                                                           |
|-----------------------------|--------|-------------------------------------------------------------------------------------------------------|
| `UNWRAP_ETH`                | 0      | Automatically unwrap base asset (e.g., convert WETH to ETH)                                           |
| `REVERT_IF_EXTERNAL_FAIL`   | 1      | Revert entire tx if external call fails                                                               |
| `PROXY_WITH_SENDER`         | 2      | Enforces sender validation via `submissionNativeSender` and `submissionChainIdFrom`                  |
| `SEND_HASHED_DATA`          | 3      | Only hashed data is passed; used to prevent unauthorized claims                                        |
| `SEND_EXTERNAL_CALL_GAS_LIMIT` | 4   | Specifies minimal gas limit for the external call (included in first 4 bytes of `data`)              |
| `MULTI_SEND`                | 5      | Executes data via Gnosis Multisend implementation inside deBridge callProxy                          |

---

`PROXY_WITH_SENDER` flag should be used if the receiving smart contract must validate that the message sender is trusted. When set, the deBridge
protocol stores `submissionNativeSender` and `submissionChainIdFrom`, allowing the recipient contract to verify the sender.

![External Call](/images/dmp/dmp-contracts-intro.avif)

The receiving smart contract can retrieve the callProxy address from the `debridgeGate` smart contract. Use
[`onlyControllingAddress`](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol#L62) modifier or
inherit from [`BridgeAppBase.sol`](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol) to
implement this validation logic properly.
